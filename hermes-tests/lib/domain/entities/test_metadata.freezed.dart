// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'test_metadata.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$TestMetadata {
  String get problemId => throw _privateConstructorUsedError;
  String get testId => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String problemId, String testId, String fromDir,
            String archiveTypeExtension)
        testToFragment,
    required TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)
        testToEncode,
    required TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)
        testToDownload,
    required TResult Function(
            String problemId,
            String testId,
            int testSize,
            String toDir,
            String archiveTypeExtension,
            Stream<Chunk> chunkStream,
            int maxTestSize)
        testToDefragment,
    required TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)
        testToDecode,
    required TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)
        testToUpload,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String problemId, String testId, String fromDir,
            String archiveTypeExtension)?
        testToFragment,
    TResult? Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToEncode,
    TResult? Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToDownload,
    TResult? Function(
            String problemId,
            String testId,
            int testSize,
            String toDir,
            String archiveTypeExtension,
            Stream<Chunk> chunkStream,
            int maxTestSize)?
        testToDefragment,
    TResult? Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToDecode,
    TResult? Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToUpload,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String problemId, String testId, String fromDir,
            String archiveTypeExtension)?
        testToFragment,
    TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToEncode,
    TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToDownload,
    TResult Function(
            String problemId,
            String testId,
            int testSize,
            String toDir,
            String archiveTypeExtension,
            Stream<Chunk> chunkStream,
            int maxTestSize)?
        testToDefragment,
    TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToDecode,
    TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToUpload,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TestToFragment value) testToFragment,
    required TResult Function(TestToEncode value) testToEncode,
    required TResult Function(TestToDownload value) testToDownload,
    required TResult Function(TestToDefragment value) testToDefragment,
    required TResult Function(TestToDecode value) testToDecode,
    required TResult Function(TestToUpload value) testToUpload,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TestToFragment value)? testToFragment,
    TResult? Function(TestToEncode value)? testToEncode,
    TResult? Function(TestToDownload value)? testToDownload,
    TResult? Function(TestToDefragment value)? testToDefragment,
    TResult? Function(TestToDecode value)? testToDecode,
    TResult? Function(TestToUpload value)? testToUpload,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TestToFragment value)? testToFragment,
    TResult Function(TestToEncode value)? testToEncode,
    TResult Function(TestToDownload value)? testToDownload,
    TResult Function(TestToDefragment value)? testToDefragment,
    TResult Function(TestToDecode value)? testToDecode,
    TResult Function(TestToUpload value)? testToUpload,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $TestMetadataCopyWith<TestMetadata> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TestMetadataCopyWith<$Res> {
  factory $TestMetadataCopyWith(
          TestMetadata value, $Res Function(TestMetadata) then) =
      _$TestMetadataCopyWithImpl<$Res, TestMetadata>;
  @useResult
  $Res call({String problemId, String testId});
}

/// @nodoc
class _$TestMetadataCopyWithImpl<$Res, $Val extends TestMetadata>
    implements $TestMetadataCopyWith<$Res> {
  _$TestMetadataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? problemId = null,
    Object? testId = null,
  }) {
    return _then(_value.copyWith(
      problemId: null == problemId
          ? _value.problemId
          : problemId // ignore: cast_nullable_to_non_nullable
              as String,
      testId: null == testId
          ? _value.testId
          : testId // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TestToFragmentCopyWith<$Res>
    implements $TestMetadataCopyWith<$Res> {
  factory _$$TestToFragmentCopyWith(
          _$TestToFragment value, $Res Function(_$TestToFragment) then) =
      __$$TestToFragmentCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String problemId,
      String testId,
      String fromDir,
      String archiveTypeExtension});
}

/// @nodoc
class __$$TestToFragmentCopyWithImpl<$Res>
    extends _$TestMetadataCopyWithImpl<$Res, _$TestToFragment>
    implements _$$TestToFragmentCopyWith<$Res> {
  __$$TestToFragmentCopyWithImpl(
      _$TestToFragment _value, $Res Function(_$TestToFragment) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? problemId = null,
    Object? testId = null,
    Object? fromDir = null,
    Object? archiveTypeExtension = null,
  }) {
    return _then(_$TestToFragment(
      problemId: null == problemId
          ? _value.problemId
          : problemId // ignore: cast_nullable_to_non_nullable
              as String,
      testId: null == testId
          ? _value.testId
          : testId // ignore: cast_nullable_to_non_nullable
              as String,
      fromDir: null == fromDir
          ? _value.fromDir
          : fromDir // ignore: cast_nullable_to_non_nullable
              as String,
      archiveTypeExtension: null == archiveTypeExtension
          ? _value.archiveTypeExtension
          : archiveTypeExtension // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$TestToFragment implements TestToFragment {
  const _$TestToFragment(
      {required this.problemId,
      required this.testId,
      required this.fromDir,
      required this.archiveTypeExtension});

  @override
  final String problemId;
  @override
  final String testId;
  @override
  final String fromDir;
  @override
  final String archiveTypeExtension;

  @override
  String toString() {
    return 'TestMetadata.testToFragment(problemId: $problemId, testId: $testId, fromDir: $fromDir, archiveTypeExtension: $archiveTypeExtension)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TestToFragment &&
            (identical(other.problemId, problemId) ||
                other.problemId == problemId) &&
            (identical(other.testId, testId) || other.testId == testId) &&
            (identical(other.fromDir, fromDir) || other.fromDir == fromDir) &&
            (identical(other.archiveTypeExtension, archiveTypeExtension) ||
                other.archiveTypeExtension == archiveTypeExtension));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, problemId, testId, fromDir, archiveTypeExtension);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TestToFragmentCopyWith<_$TestToFragment> get copyWith =>
      __$$TestToFragmentCopyWithImpl<_$TestToFragment>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String problemId, String testId, String fromDir,
            String archiveTypeExtension)
        testToFragment,
    required TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)
        testToEncode,
    required TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)
        testToDownload,
    required TResult Function(
            String problemId,
            String testId,
            int testSize,
            String toDir,
            String archiveTypeExtension,
            Stream<Chunk> chunkStream,
            int maxTestSize)
        testToDefragment,
    required TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)
        testToDecode,
    required TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)
        testToUpload,
  }) {
    return testToFragment(problemId, testId, fromDir, archiveTypeExtension);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String problemId, String testId, String fromDir,
            String archiveTypeExtension)?
        testToFragment,
    TResult? Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToEncode,
    TResult? Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToDownload,
    TResult? Function(
            String problemId,
            String testId,
            int testSize,
            String toDir,
            String archiveTypeExtension,
            Stream<Chunk> chunkStream,
            int maxTestSize)?
        testToDefragment,
    TResult? Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToDecode,
    TResult? Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToUpload,
  }) {
    return testToFragment?.call(
        problemId, testId, fromDir, archiveTypeExtension);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String problemId, String testId, String fromDir,
            String archiveTypeExtension)?
        testToFragment,
    TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToEncode,
    TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToDownload,
    TResult Function(
            String problemId,
            String testId,
            int testSize,
            String toDir,
            String archiveTypeExtension,
            Stream<Chunk> chunkStream,
            int maxTestSize)?
        testToDefragment,
    TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToDecode,
    TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToUpload,
    required TResult orElse(),
  }) {
    if (testToFragment != null) {
      return testToFragment(problemId, testId, fromDir, archiveTypeExtension);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TestToFragment value) testToFragment,
    required TResult Function(TestToEncode value) testToEncode,
    required TResult Function(TestToDownload value) testToDownload,
    required TResult Function(TestToDefragment value) testToDefragment,
    required TResult Function(TestToDecode value) testToDecode,
    required TResult Function(TestToUpload value) testToUpload,
  }) {
    return testToFragment(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TestToFragment value)? testToFragment,
    TResult? Function(TestToEncode value)? testToEncode,
    TResult? Function(TestToDownload value)? testToDownload,
    TResult? Function(TestToDefragment value)? testToDefragment,
    TResult? Function(TestToDecode value)? testToDecode,
    TResult? Function(TestToUpload value)? testToUpload,
  }) {
    return testToFragment?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TestToFragment value)? testToFragment,
    TResult Function(TestToEncode value)? testToEncode,
    TResult Function(TestToDownload value)? testToDownload,
    TResult Function(TestToDefragment value)? testToDefragment,
    TResult Function(TestToDecode value)? testToDecode,
    TResult Function(TestToUpload value)? testToUpload,
    required TResult orElse(),
  }) {
    if (testToFragment != null) {
      return testToFragment(this);
    }
    return orElse();
  }
}

abstract class TestToFragment implements TestMetadata {
  const factory TestToFragment(
      {required final String problemId,
      required final String testId,
      required final String fromDir,
      required final String archiveTypeExtension}) = _$TestToFragment;

  @override
  String get problemId;
  @override
  String get testId;
  String get fromDir;
  String get archiveTypeExtension;
  @override
  @JsonKey(ignore: true)
  _$$TestToFragmentCopyWith<_$TestToFragment> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TestToEncodeCopyWith<$Res>
    implements $TestMetadataCopyWith<$Res> {
  factory _$$TestToEncodeCopyWith(
          _$TestToEncode value, $Res Function(_$TestToEncode) then) =
      __$$TestToEncodeCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String problemId,
      String testId,
      String fromDir,
      String toDir,
      String archiveTypeExtension,
      String inputFilename,
      String outputFilename});
}

/// @nodoc
class __$$TestToEncodeCopyWithImpl<$Res>
    extends _$TestMetadataCopyWithImpl<$Res, _$TestToEncode>
    implements _$$TestToEncodeCopyWith<$Res> {
  __$$TestToEncodeCopyWithImpl(
      _$TestToEncode _value, $Res Function(_$TestToEncode) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? problemId = null,
    Object? testId = null,
    Object? fromDir = null,
    Object? toDir = null,
    Object? archiveTypeExtension = null,
    Object? inputFilename = null,
    Object? outputFilename = null,
  }) {
    return _then(_$TestToEncode(
      problemId: null == problemId
          ? _value.problemId
          : problemId // ignore: cast_nullable_to_non_nullable
              as String,
      testId: null == testId
          ? _value.testId
          : testId // ignore: cast_nullable_to_non_nullable
              as String,
      fromDir: null == fromDir
          ? _value.fromDir
          : fromDir // ignore: cast_nullable_to_non_nullable
              as String,
      toDir: null == toDir
          ? _value.toDir
          : toDir // ignore: cast_nullable_to_non_nullable
              as String,
      archiveTypeExtension: null == archiveTypeExtension
          ? _value.archiveTypeExtension
          : archiveTypeExtension // ignore: cast_nullable_to_non_nullable
              as String,
      inputFilename: null == inputFilename
          ? _value.inputFilename
          : inputFilename // ignore: cast_nullable_to_non_nullable
              as String,
      outputFilename: null == outputFilename
          ? _value.outputFilename
          : outputFilename // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$TestToEncode implements TestToEncode {
  const _$TestToEncode(
      {required this.problemId,
      required this.testId,
      required this.fromDir,
      required this.toDir,
      required this.archiveTypeExtension,
      required this.inputFilename,
      required this.outputFilename});

  @override
  final String problemId;
  @override
  final String testId;
  @override
  final String fromDir;
  @override
  final String toDir;
  @override
  final String archiveTypeExtension;
  @override
  final String inputFilename;
  @override
  final String outputFilename;

  @override
  String toString() {
    return 'TestMetadata.testToEncode(problemId: $problemId, testId: $testId, fromDir: $fromDir, toDir: $toDir, archiveTypeExtension: $archiveTypeExtension, inputFilename: $inputFilename, outputFilename: $outputFilename)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TestToEncode &&
            (identical(other.problemId, problemId) ||
                other.problemId == problemId) &&
            (identical(other.testId, testId) || other.testId == testId) &&
            (identical(other.fromDir, fromDir) || other.fromDir == fromDir) &&
            (identical(other.toDir, toDir) || other.toDir == toDir) &&
            (identical(other.archiveTypeExtension, archiveTypeExtension) ||
                other.archiveTypeExtension == archiveTypeExtension) &&
            (identical(other.inputFilename, inputFilename) ||
                other.inputFilename == inputFilename) &&
            (identical(other.outputFilename, outputFilename) ||
                other.outputFilename == outputFilename));
  }

  @override
  int get hashCode => Object.hash(runtimeType, problemId, testId, fromDir,
      toDir, archiveTypeExtension, inputFilename, outputFilename);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TestToEncodeCopyWith<_$TestToEncode> get copyWith =>
      __$$TestToEncodeCopyWithImpl<_$TestToEncode>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String problemId, String testId, String fromDir,
            String archiveTypeExtension)
        testToFragment,
    required TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)
        testToEncode,
    required TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)
        testToDownload,
    required TResult Function(
            String problemId,
            String testId,
            int testSize,
            String toDir,
            String archiveTypeExtension,
            Stream<Chunk> chunkStream,
            int maxTestSize)
        testToDefragment,
    required TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)
        testToDecode,
    required TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)
        testToUpload,
  }) {
    return testToEncode(problemId, testId, fromDir, toDir, archiveTypeExtension,
        inputFilename, outputFilename);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String problemId, String testId, String fromDir,
            String archiveTypeExtension)?
        testToFragment,
    TResult? Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToEncode,
    TResult? Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToDownload,
    TResult? Function(
            String problemId,
            String testId,
            int testSize,
            String toDir,
            String archiveTypeExtension,
            Stream<Chunk> chunkStream,
            int maxTestSize)?
        testToDefragment,
    TResult? Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToDecode,
    TResult? Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToUpload,
  }) {
    return testToEncode?.call(problemId, testId, fromDir, toDir,
        archiveTypeExtension, inputFilename, outputFilename);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String problemId, String testId, String fromDir,
            String archiveTypeExtension)?
        testToFragment,
    TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToEncode,
    TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToDownload,
    TResult Function(
            String problemId,
            String testId,
            int testSize,
            String toDir,
            String archiveTypeExtension,
            Stream<Chunk> chunkStream,
            int maxTestSize)?
        testToDefragment,
    TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToDecode,
    TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToUpload,
    required TResult orElse(),
  }) {
    if (testToEncode != null) {
      return testToEncode(problemId, testId, fromDir, toDir,
          archiveTypeExtension, inputFilename, outputFilename);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TestToFragment value) testToFragment,
    required TResult Function(TestToEncode value) testToEncode,
    required TResult Function(TestToDownload value) testToDownload,
    required TResult Function(TestToDefragment value) testToDefragment,
    required TResult Function(TestToDecode value) testToDecode,
    required TResult Function(TestToUpload value) testToUpload,
  }) {
    return testToEncode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TestToFragment value)? testToFragment,
    TResult? Function(TestToEncode value)? testToEncode,
    TResult? Function(TestToDownload value)? testToDownload,
    TResult? Function(TestToDefragment value)? testToDefragment,
    TResult? Function(TestToDecode value)? testToDecode,
    TResult? Function(TestToUpload value)? testToUpload,
  }) {
    return testToEncode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TestToFragment value)? testToFragment,
    TResult Function(TestToEncode value)? testToEncode,
    TResult Function(TestToDownload value)? testToDownload,
    TResult Function(TestToDefragment value)? testToDefragment,
    TResult Function(TestToDecode value)? testToDecode,
    TResult Function(TestToUpload value)? testToUpload,
    required TResult orElse(),
  }) {
    if (testToEncode != null) {
      return testToEncode(this);
    }
    return orElse();
  }
}

abstract class TestToEncode implements TestMetadata {
  const factory TestToEncode(
      {required final String problemId,
      required final String testId,
      required final String fromDir,
      required final String toDir,
      required final String archiveTypeExtension,
      required final String inputFilename,
      required final String outputFilename}) = _$TestToEncode;

  @override
  String get problemId;
  @override
  String get testId;
  String get fromDir;
  String get toDir;
  String get archiveTypeExtension;
  String get inputFilename;
  String get outputFilename;
  @override
  @JsonKey(ignore: true)
  _$$TestToEncodeCopyWith<_$TestToEncode> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TestToDownloadCopyWith<$Res>
    implements $TestMetadataCopyWith<$Res> {
  factory _$$TestToDownloadCopyWith(
          _$TestToDownload value, $Res Function(_$TestToDownload) then) =
      __$$TestToDownloadCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String problemId,
      String testId,
      String fromDir,
      String toDir,
      String inputFilename,
      String outputFilename});
}

/// @nodoc
class __$$TestToDownloadCopyWithImpl<$Res>
    extends _$TestMetadataCopyWithImpl<$Res, _$TestToDownload>
    implements _$$TestToDownloadCopyWith<$Res> {
  __$$TestToDownloadCopyWithImpl(
      _$TestToDownload _value, $Res Function(_$TestToDownload) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? problemId = null,
    Object? testId = null,
    Object? fromDir = null,
    Object? toDir = null,
    Object? inputFilename = null,
    Object? outputFilename = null,
  }) {
    return _then(_$TestToDownload(
      problemId: null == problemId
          ? _value.problemId
          : problemId // ignore: cast_nullable_to_non_nullable
              as String,
      testId: null == testId
          ? _value.testId
          : testId // ignore: cast_nullable_to_non_nullable
              as String,
      fromDir: null == fromDir
          ? _value.fromDir
          : fromDir // ignore: cast_nullable_to_non_nullable
              as String,
      toDir: null == toDir
          ? _value.toDir
          : toDir // ignore: cast_nullable_to_non_nullable
              as String,
      inputFilename: null == inputFilename
          ? _value.inputFilename
          : inputFilename // ignore: cast_nullable_to_non_nullable
              as String,
      outputFilename: null == outputFilename
          ? _value.outputFilename
          : outputFilename // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$TestToDownload implements TestToDownload {
  const _$TestToDownload(
      {required this.problemId,
      required this.testId,
      required this.fromDir,
      required this.toDir,
      required this.inputFilename,
      required this.outputFilename});

  @override
  final String problemId;
  @override
  final String testId;
  @override
  final String fromDir;
  @override
  final String toDir;
  @override
  final String inputFilename;
  @override
  final String outputFilename;

  @override
  String toString() {
    return 'TestMetadata.testToDownload(problemId: $problemId, testId: $testId, fromDir: $fromDir, toDir: $toDir, inputFilename: $inputFilename, outputFilename: $outputFilename)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TestToDownload &&
            (identical(other.problemId, problemId) ||
                other.problemId == problemId) &&
            (identical(other.testId, testId) || other.testId == testId) &&
            (identical(other.fromDir, fromDir) || other.fromDir == fromDir) &&
            (identical(other.toDir, toDir) || other.toDir == toDir) &&
            (identical(other.inputFilename, inputFilename) ||
                other.inputFilename == inputFilename) &&
            (identical(other.outputFilename, outputFilename) ||
                other.outputFilename == outputFilename));
  }

  @override
  int get hashCode => Object.hash(runtimeType, problemId, testId, fromDir,
      toDir, inputFilename, outputFilename);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TestToDownloadCopyWith<_$TestToDownload> get copyWith =>
      __$$TestToDownloadCopyWithImpl<_$TestToDownload>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String problemId, String testId, String fromDir,
            String archiveTypeExtension)
        testToFragment,
    required TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)
        testToEncode,
    required TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)
        testToDownload,
    required TResult Function(
            String problemId,
            String testId,
            int testSize,
            String toDir,
            String archiveTypeExtension,
            Stream<Chunk> chunkStream,
            int maxTestSize)
        testToDefragment,
    required TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)
        testToDecode,
    required TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)
        testToUpload,
  }) {
    return testToDownload(
        problemId, testId, fromDir, toDir, inputFilename, outputFilename);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String problemId, String testId, String fromDir,
            String archiveTypeExtension)?
        testToFragment,
    TResult? Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToEncode,
    TResult? Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToDownload,
    TResult? Function(
            String problemId,
            String testId,
            int testSize,
            String toDir,
            String archiveTypeExtension,
            Stream<Chunk> chunkStream,
            int maxTestSize)?
        testToDefragment,
    TResult? Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToDecode,
    TResult? Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToUpload,
  }) {
    return testToDownload?.call(
        problemId, testId, fromDir, toDir, inputFilename, outputFilename);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String problemId, String testId, String fromDir,
            String archiveTypeExtension)?
        testToFragment,
    TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToEncode,
    TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToDownload,
    TResult Function(
            String problemId,
            String testId,
            int testSize,
            String toDir,
            String archiveTypeExtension,
            Stream<Chunk> chunkStream,
            int maxTestSize)?
        testToDefragment,
    TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToDecode,
    TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToUpload,
    required TResult orElse(),
  }) {
    if (testToDownload != null) {
      return testToDownload(
          problemId, testId, fromDir, toDir, inputFilename, outputFilename);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TestToFragment value) testToFragment,
    required TResult Function(TestToEncode value) testToEncode,
    required TResult Function(TestToDownload value) testToDownload,
    required TResult Function(TestToDefragment value) testToDefragment,
    required TResult Function(TestToDecode value) testToDecode,
    required TResult Function(TestToUpload value) testToUpload,
  }) {
    return testToDownload(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TestToFragment value)? testToFragment,
    TResult? Function(TestToEncode value)? testToEncode,
    TResult? Function(TestToDownload value)? testToDownload,
    TResult? Function(TestToDefragment value)? testToDefragment,
    TResult? Function(TestToDecode value)? testToDecode,
    TResult? Function(TestToUpload value)? testToUpload,
  }) {
    return testToDownload?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TestToFragment value)? testToFragment,
    TResult Function(TestToEncode value)? testToEncode,
    TResult Function(TestToDownload value)? testToDownload,
    TResult Function(TestToDefragment value)? testToDefragment,
    TResult Function(TestToDecode value)? testToDecode,
    TResult Function(TestToUpload value)? testToUpload,
    required TResult orElse(),
  }) {
    if (testToDownload != null) {
      return testToDownload(this);
    }
    return orElse();
  }
}

abstract class TestToDownload implements TestMetadata {
  const factory TestToDownload(
      {required final String problemId,
      required final String testId,
      required final String fromDir,
      required final String toDir,
      required final String inputFilename,
      required final String outputFilename}) = _$TestToDownload;

  @override
  String get problemId;
  @override
  String get testId;
  String get fromDir;
  String get toDir;
  String get inputFilename;
  String get outputFilename;
  @override
  @JsonKey(ignore: true)
  _$$TestToDownloadCopyWith<_$TestToDownload> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TestToDefragmentCopyWith<$Res>
    implements $TestMetadataCopyWith<$Res> {
  factory _$$TestToDefragmentCopyWith(
          _$TestToDefragment value, $Res Function(_$TestToDefragment) then) =
      __$$TestToDefragmentCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String problemId,
      String testId,
      int testSize,
      String toDir,
      String archiveTypeExtension,
      Stream<Chunk> chunkStream,
      int maxTestSize});
}

/// @nodoc
class __$$TestToDefragmentCopyWithImpl<$Res>
    extends _$TestMetadataCopyWithImpl<$Res, _$TestToDefragment>
    implements _$$TestToDefragmentCopyWith<$Res> {
  __$$TestToDefragmentCopyWithImpl(
      _$TestToDefragment _value, $Res Function(_$TestToDefragment) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? problemId = null,
    Object? testId = null,
    Object? testSize = null,
    Object? toDir = null,
    Object? archiveTypeExtension = null,
    Object? chunkStream = null,
    Object? maxTestSize = null,
  }) {
    return _then(_$TestToDefragment(
      problemId: null == problemId
          ? _value.problemId
          : problemId // ignore: cast_nullable_to_non_nullable
              as String,
      testId: null == testId
          ? _value.testId
          : testId // ignore: cast_nullable_to_non_nullable
              as String,
      testSize: null == testSize
          ? _value.testSize
          : testSize // ignore: cast_nullable_to_non_nullable
              as int,
      toDir: null == toDir
          ? _value.toDir
          : toDir // ignore: cast_nullable_to_non_nullable
              as String,
      archiveTypeExtension: null == archiveTypeExtension
          ? _value.archiveTypeExtension
          : archiveTypeExtension // ignore: cast_nullable_to_non_nullable
              as String,
      chunkStream: null == chunkStream
          ? _value.chunkStream
          : chunkStream // ignore: cast_nullable_to_non_nullable
              as Stream<Chunk>,
      maxTestSize: null == maxTestSize
          ? _value.maxTestSize
          : maxTestSize // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$TestToDefragment implements TestToDefragment {
  const _$TestToDefragment(
      {required this.problemId,
      required this.testId,
      required this.testSize,
      required this.toDir,
      required this.archiveTypeExtension,
      required this.chunkStream,
      required this.maxTestSize});

  @override
  final String problemId;
  @override
  final String testId;
  @override
  final int testSize;
  @override
  final String toDir;
  @override
  final String archiveTypeExtension;
  @override
  final Stream<Chunk> chunkStream;
  @override
  final int maxTestSize;

  @override
  String toString() {
    return 'TestMetadata.testToDefragment(problemId: $problemId, testId: $testId, testSize: $testSize, toDir: $toDir, archiveTypeExtension: $archiveTypeExtension, chunkStream: $chunkStream, maxTestSize: $maxTestSize)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TestToDefragment &&
            (identical(other.problemId, problemId) ||
                other.problemId == problemId) &&
            (identical(other.testId, testId) || other.testId == testId) &&
            (identical(other.testSize, testSize) ||
                other.testSize == testSize) &&
            (identical(other.toDir, toDir) || other.toDir == toDir) &&
            (identical(other.archiveTypeExtension, archiveTypeExtension) ||
                other.archiveTypeExtension == archiveTypeExtension) &&
            (identical(other.chunkStream, chunkStream) ||
                other.chunkStream == chunkStream) &&
            (identical(other.maxTestSize, maxTestSize) ||
                other.maxTestSize == maxTestSize));
  }

  @override
  int get hashCode => Object.hash(runtimeType, problemId, testId, testSize,
      toDir, archiveTypeExtension, chunkStream, maxTestSize);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TestToDefragmentCopyWith<_$TestToDefragment> get copyWith =>
      __$$TestToDefragmentCopyWithImpl<_$TestToDefragment>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String problemId, String testId, String fromDir,
            String archiveTypeExtension)
        testToFragment,
    required TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)
        testToEncode,
    required TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)
        testToDownload,
    required TResult Function(
            String problemId,
            String testId,
            int testSize,
            String toDir,
            String archiveTypeExtension,
            Stream<Chunk> chunkStream,
            int maxTestSize)
        testToDefragment,
    required TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)
        testToDecode,
    required TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)
        testToUpload,
  }) {
    return testToDefragment(problemId, testId, testSize, toDir,
        archiveTypeExtension, chunkStream, maxTestSize);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String problemId, String testId, String fromDir,
            String archiveTypeExtension)?
        testToFragment,
    TResult? Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToEncode,
    TResult? Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToDownload,
    TResult? Function(
            String problemId,
            String testId,
            int testSize,
            String toDir,
            String archiveTypeExtension,
            Stream<Chunk> chunkStream,
            int maxTestSize)?
        testToDefragment,
    TResult? Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToDecode,
    TResult? Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToUpload,
  }) {
    return testToDefragment?.call(problemId, testId, testSize, toDir,
        archiveTypeExtension, chunkStream, maxTestSize);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String problemId, String testId, String fromDir,
            String archiveTypeExtension)?
        testToFragment,
    TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToEncode,
    TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToDownload,
    TResult Function(
            String problemId,
            String testId,
            int testSize,
            String toDir,
            String archiveTypeExtension,
            Stream<Chunk> chunkStream,
            int maxTestSize)?
        testToDefragment,
    TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToDecode,
    TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToUpload,
    required TResult orElse(),
  }) {
    if (testToDefragment != null) {
      return testToDefragment(problemId, testId, testSize, toDir,
          archiveTypeExtension, chunkStream, maxTestSize);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TestToFragment value) testToFragment,
    required TResult Function(TestToEncode value) testToEncode,
    required TResult Function(TestToDownload value) testToDownload,
    required TResult Function(TestToDefragment value) testToDefragment,
    required TResult Function(TestToDecode value) testToDecode,
    required TResult Function(TestToUpload value) testToUpload,
  }) {
    return testToDefragment(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TestToFragment value)? testToFragment,
    TResult? Function(TestToEncode value)? testToEncode,
    TResult? Function(TestToDownload value)? testToDownload,
    TResult? Function(TestToDefragment value)? testToDefragment,
    TResult? Function(TestToDecode value)? testToDecode,
    TResult? Function(TestToUpload value)? testToUpload,
  }) {
    return testToDefragment?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TestToFragment value)? testToFragment,
    TResult Function(TestToEncode value)? testToEncode,
    TResult Function(TestToDownload value)? testToDownload,
    TResult Function(TestToDefragment value)? testToDefragment,
    TResult Function(TestToDecode value)? testToDecode,
    TResult Function(TestToUpload value)? testToUpload,
    required TResult orElse(),
  }) {
    if (testToDefragment != null) {
      return testToDefragment(this);
    }
    return orElse();
  }
}

abstract class TestToDefragment implements TestMetadata {
  const factory TestToDefragment(
      {required final String problemId,
      required final String testId,
      required final int testSize,
      required final String toDir,
      required final String archiveTypeExtension,
      required final Stream<Chunk> chunkStream,
      required final int maxTestSize}) = _$TestToDefragment;

  @override
  String get problemId;
  @override
  String get testId;
  int get testSize;
  String get toDir;
  String get archiveTypeExtension;
  Stream<Chunk> get chunkStream;
  int get maxTestSize;
  @override
  @JsonKey(ignore: true)
  _$$TestToDefragmentCopyWith<_$TestToDefragment> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TestToDecodeCopyWith<$Res>
    implements $TestMetadataCopyWith<$Res> {
  factory _$$TestToDecodeCopyWith(
          _$TestToDecode value, $Res Function(_$TestToDecode) then) =
      __$$TestToDecodeCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String problemId,
      String testId,
      String fromDir,
      String toDir,
      String archiveTypeExtension,
      String inputFilename,
      String outputFilename});
}

/// @nodoc
class __$$TestToDecodeCopyWithImpl<$Res>
    extends _$TestMetadataCopyWithImpl<$Res, _$TestToDecode>
    implements _$$TestToDecodeCopyWith<$Res> {
  __$$TestToDecodeCopyWithImpl(
      _$TestToDecode _value, $Res Function(_$TestToDecode) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? problemId = null,
    Object? testId = null,
    Object? fromDir = null,
    Object? toDir = null,
    Object? archiveTypeExtension = null,
    Object? inputFilename = null,
    Object? outputFilename = null,
  }) {
    return _then(_$TestToDecode(
      problemId: null == problemId
          ? _value.problemId
          : problemId // ignore: cast_nullable_to_non_nullable
              as String,
      testId: null == testId
          ? _value.testId
          : testId // ignore: cast_nullable_to_non_nullable
              as String,
      fromDir: null == fromDir
          ? _value.fromDir
          : fromDir // ignore: cast_nullable_to_non_nullable
              as String,
      toDir: null == toDir
          ? _value.toDir
          : toDir // ignore: cast_nullable_to_non_nullable
              as String,
      archiveTypeExtension: null == archiveTypeExtension
          ? _value.archiveTypeExtension
          : archiveTypeExtension // ignore: cast_nullable_to_non_nullable
              as String,
      inputFilename: null == inputFilename
          ? _value.inputFilename
          : inputFilename // ignore: cast_nullable_to_non_nullable
              as String,
      outputFilename: null == outputFilename
          ? _value.outputFilename
          : outputFilename // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$TestToDecode implements TestToDecode {
  const _$TestToDecode(
      {required this.problemId,
      required this.testId,
      required this.fromDir,
      required this.toDir,
      required this.archiveTypeExtension,
      required this.inputFilename,
      required this.outputFilename});

  @override
  final String problemId;
  @override
  final String testId;
  @override
  final String fromDir;
  @override
  final String toDir;
  @override
  final String archiveTypeExtension;
  @override
  final String inputFilename;
  @override
  final String outputFilename;

  @override
  String toString() {
    return 'TestMetadata.testToDecode(problemId: $problemId, testId: $testId, fromDir: $fromDir, toDir: $toDir, archiveTypeExtension: $archiveTypeExtension, inputFilename: $inputFilename, outputFilename: $outputFilename)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TestToDecode &&
            (identical(other.problemId, problemId) ||
                other.problemId == problemId) &&
            (identical(other.testId, testId) || other.testId == testId) &&
            (identical(other.fromDir, fromDir) || other.fromDir == fromDir) &&
            (identical(other.toDir, toDir) || other.toDir == toDir) &&
            (identical(other.archiveTypeExtension, archiveTypeExtension) ||
                other.archiveTypeExtension == archiveTypeExtension) &&
            (identical(other.inputFilename, inputFilename) ||
                other.inputFilename == inputFilename) &&
            (identical(other.outputFilename, outputFilename) ||
                other.outputFilename == outputFilename));
  }

  @override
  int get hashCode => Object.hash(runtimeType, problemId, testId, fromDir,
      toDir, archiveTypeExtension, inputFilename, outputFilename);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TestToDecodeCopyWith<_$TestToDecode> get copyWith =>
      __$$TestToDecodeCopyWithImpl<_$TestToDecode>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String problemId, String testId, String fromDir,
            String archiveTypeExtension)
        testToFragment,
    required TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)
        testToEncode,
    required TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)
        testToDownload,
    required TResult Function(
            String problemId,
            String testId,
            int testSize,
            String toDir,
            String archiveTypeExtension,
            Stream<Chunk> chunkStream,
            int maxTestSize)
        testToDefragment,
    required TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)
        testToDecode,
    required TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)
        testToUpload,
  }) {
    return testToDecode(problemId, testId, fromDir, toDir, archiveTypeExtension,
        inputFilename, outputFilename);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String problemId, String testId, String fromDir,
            String archiveTypeExtension)?
        testToFragment,
    TResult? Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToEncode,
    TResult? Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToDownload,
    TResult? Function(
            String problemId,
            String testId,
            int testSize,
            String toDir,
            String archiveTypeExtension,
            Stream<Chunk> chunkStream,
            int maxTestSize)?
        testToDefragment,
    TResult? Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToDecode,
    TResult? Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToUpload,
  }) {
    return testToDecode?.call(problemId, testId, fromDir, toDir,
        archiveTypeExtension, inputFilename, outputFilename);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String problemId, String testId, String fromDir,
            String archiveTypeExtension)?
        testToFragment,
    TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToEncode,
    TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToDownload,
    TResult Function(
            String problemId,
            String testId,
            int testSize,
            String toDir,
            String archiveTypeExtension,
            Stream<Chunk> chunkStream,
            int maxTestSize)?
        testToDefragment,
    TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToDecode,
    TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToUpload,
    required TResult orElse(),
  }) {
    if (testToDecode != null) {
      return testToDecode(problemId, testId, fromDir, toDir,
          archiveTypeExtension, inputFilename, outputFilename);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TestToFragment value) testToFragment,
    required TResult Function(TestToEncode value) testToEncode,
    required TResult Function(TestToDownload value) testToDownload,
    required TResult Function(TestToDefragment value) testToDefragment,
    required TResult Function(TestToDecode value) testToDecode,
    required TResult Function(TestToUpload value) testToUpload,
  }) {
    return testToDecode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TestToFragment value)? testToFragment,
    TResult? Function(TestToEncode value)? testToEncode,
    TResult? Function(TestToDownload value)? testToDownload,
    TResult? Function(TestToDefragment value)? testToDefragment,
    TResult? Function(TestToDecode value)? testToDecode,
    TResult? Function(TestToUpload value)? testToUpload,
  }) {
    return testToDecode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TestToFragment value)? testToFragment,
    TResult Function(TestToEncode value)? testToEncode,
    TResult Function(TestToDownload value)? testToDownload,
    TResult Function(TestToDefragment value)? testToDefragment,
    TResult Function(TestToDecode value)? testToDecode,
    TResult Function(TestToUpload value)? testToUpload,
    required TResult orElse(),
  }) {
    if (testToDecode != null) {
      return testToDecode(this);
    }
    return orElse();
  }
}

abstract class TestToDecode implements TestMetadata {
  const factory TestToDecode(
      {required final String problemId,
      required final String testId,
      required final String fromDir,
      required final String toDir,
      required final String archiveTypeExtension,
      required final String inputFilename,
      required final String outputFilename}) = _$TestToDecode;

  @override
  String get problemId;
  @override
  String get testId;
  String get fromDir;
  String get toDir;
  String get archiveTypeExtension;
  String get inputFilename;
  String get outputFilename;
  @override
  @JsonKey(ignore: true)
  _$$TestToDecodeCopyWith<_$TestToDecode> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TestToUploadCopyWith<$Res>
    implements $TestMetadataCopyWith<$Res> {
  factory _$$TestToUploadCopyWith(
          _$TestToUpload value, $Res Function(_$TestToUpload) then) =
      __$$TestToUploadCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String problemId,
      String testId,
      String fromDir,
      String toDir,
      String inputFilename,
      String outputFilename});
}

/// @nodoc
class __$$TestToUploadCopyWithImpl<$Res>
    extends _$TestMetadataCopyWithImpl<$Res, _$TestToUpload>
    implements _$$TestToUploadCopyWith<$Res> {
  __$$TestToUploadCopyWithImpl(
      _$TestToUpload _value, $Res Function(_$TestToUpload) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? problemId = null,
    Object? testId = null,
    Object? fromDir = null,
    Object? toDir = null,
    Object? inputFilename = null,
    Object? outputFilename = null,
  }) {
    return _then(_$TestToUpload(
      problemId: null == problemId
          ? _value.problemId
          : problemId // ignore: cast_nullable_to_non_nullable
              as String,
      testId: null == testId
          ? _value.testId
          : testId // ignore: cast_nullable_to_non_nullable
              as String,
      fromDir: null == fromDir
          ? _value.fromDir
          : fromDir // ignore: cast_nullable_to_non_nullable
              as String,
      toDir: null == toDir
          ? _value.toDir
          : toDir // ignore: cast_nullable_to_non_nullable
              as String,
      inputFilename: null == inputFilename
          ? _value.inputFilename
          : inputFilename // ignore: cast_nullable_to_non_nullable
              as String,
      outputFilename: null == outputFilename
          ? _value.outputFilename
          : outputFilename // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$TestToUpload implements TestToUpload {
  const _$TestToUpload(
      {required this.problemId,
      required this.testId,
      required this.fromDir,
      required this.toDir,
      required this.inputFilename,
      required this.outputFilename});

  @override
  final String problemId;
  @override
  final String testId;
  @override
  final String fromDir;
  @override
  final String toDir;
  @override
  final String inputFilename;
  @override
  final String outputFilename;

  @override
  String toString() {
    return 'TestMetadata.testToUpload(problemId: $problemId, testId: $testId, fromDir: $fromDir, toDir: $toDir, inputFilename: $inputFilename, outputFilename: $outputFilename)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TestToUpload &&
            (identical(other.problemId, problemId) ||
                other.problemId == problemId) &&
            (identical(other.testId, testId) || other.testId == testId) &&
            (identical(other.fromDir, fromDir) || other.fromDir == fromDir) &&
            (identical(other.toDir, toDir) || other.toDir == toDir) &&
            (identical(other.inputFilename, inputFilename) ||
                other.inputFilename == inputFilename) &&
            (identical(other.outputFilename, outputFilename) ||
                other.outputFilename == outputFilename));
  }

  @override
  int get hashCode => Object.hash(runtimeType, problemId, testId, fromDir,
      toDir, inputFilename, outputFilename);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TestToUploadCopyWith<_$TestToUpload> get copyWith =>
      __$$TestToUploadCopyWithImpl<_$TestToUpload>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String problemId, String testId, String fromDir,
            String archiveTypeExtension)
        testToFragment,
    required TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)
        testToEncode,
    required TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)
        testToDownload,
    required TResult Function(
            String problemId,
            String testId,
            int testSize,
            String toDir,
            String archiveTypeExtension,
            Stream<Chunk> chunkStream,
            int maxTestSize)
        testToDefragment,
    required TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)
        testToDecode,
    required TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)
        testToUpload,
  }) {
    return testToUpload(
        problemId, testId, fromDir, toDir, inputFilename, outputFilename);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String problemId, String testId, String fromDir,
            String archiveTypeExtension)?
        testToFragment,
    TResult? Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToEncode,
    TResult? Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToDownload,
    TResult? Function(
            String problemId,
            String testId,
            int testSize,
            String toDir,
            String archiveTypeExtension,
            Stream<Chunk> chunkStream,
            int maxTestSize)?
        testToDefragment,
    TResult? Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToDecode,
    TResult? Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToUpload,
  }) {
    return testToUpload?.call(
        problemId, testId, fromDir, toDir, inputFilename, outputFilename);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String problemId, String testId, String fromDir,
            String archiveTypeExtension)?
        testToFragment,
    TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToEncode,
    TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToDownload,
    TResult Function(
            String problemId,
            String testId,
            int testSize,
            String toDir,
            String archiveTypeExtension,
            Stream<Chunk> chunkStream,
            int maxTestSize)?
        testToDefragment,
    TResult Function(
            String problemId,
            String testId,
            String fromDir,
            String toDir,
            String archiveTypeExtension,
            String inputFilename,
            String outputFilename)?
        testToDecode,
    TResult Function(String problemId, String testId, String fromDir,
            String toDir, String inputFilename, String outputFilename)?
        testToUpload,
    required TResult orElse(),
  }) {
    if (testToUpload != null) {
      return testToUpload(
          problemId, testId, fromDir, toDir, inputFilename, outputFilename);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TestToFragment value) testToFragment,
    required TResult Function(TestToEncode value) testToEncode,
    required TResult Function(TestToDownload value) testToDownload,
    required TResult Function(TestToDefragment value) testToDefragment,
    required TResult Function(TestToDecode value) testToDecode,
    required TResult Function(TestToUpload value) testToUpload,
  }) {
    return testToUpload(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TestToFragment value)? testToFragment,
    TResult? Function(TestToEncode value)? testToEncode,
    TResult? Function(TestToDownload value)? testToDownload,
    TResult? Function(TestToDefragment value)? testToDefragment,
    TResult? Function(TestToDecode value)? testToDecode,
    TResult? Function(TestToUpload value)? testToUpload,
  }) {
    return testToUpload?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TestToFragment value)? testToFragment,
    TResult Function(TestToEncode value)? testToEncode,
    TResult Function(TestToDownload value)? testToDownload,
    TResult Function(TestToDefragment value)? testToDefragment,
    TResult Function(TestToDecode value)? testToDecode,
    TResult Function(TestToUpload value)? testToUpload,
    required TResult orElse(),
  }) {
    if (testToUpload != null) {
      return testToUpload(this);
    }
    return orElse();
  }
}

abstract class TestToUpload implements TestMetadata {
  const factory TestToUpload(
      {required final String problemId,
      required final String testId,
      required final String fromDir,
      required final String toDir,
      required final String inputFilename,
      required final String outputFilename}) = _$TestToUpload;

  @override
  String get problemId;
  @override
  String get testId;
  String get fromDir;
  String get toDir;
  String get inputFilename;
  String get outputFilename;
  @override
  @JsonKey(ignore: true)
  _$$TestToUploadCopyWith<_$TestToUpload> get copyWith =>
      throw _privateConstructorUsedError;
}
